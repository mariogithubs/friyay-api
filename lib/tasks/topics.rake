namespace :topics do
  desc 'Move topic to new domain (interactive)'
  task move_to_domain: :environment do
    puts "DANGER: This is a WIP, just beware that its possible to kick off a lot of activity if you do certain things.\n"
    puts 'This utility moves a Hive from one domain to another.'
    puts 'It will automatically move all SubHives, but not tips (content).'
    puts 'You may choose to also move tips (content) during the process.'
    puts 'It will guide you through the process. Please read the question carefully.'
    puts 'You will need to know the user_id of the creator of the hives.'
    puts 'You may also need to know the topic_id of the topic you are moving.'
    puts 'Be careful, '
    puts "You can also use 'all' to move content generated by all users.\n"

    printf 'Do you want to continue?(yes/no)'
    continue = STDIN.gets.chomp
    next unless continue == 'yes'

    printf 'What is the tenant_name of the old (FROM) domain (public or tenant_name)? '
    old_tenant_name = STDIN.gets.chomp

    old_domain = domain_or_public(old_tenant_name)
    puts 'Domain not found' unless old_domain
    next unless old_domain

    printf 'What is the tenant_name of the new (TO) domain (public or tenant_name)? '
    new_tenant_name = STDIN.gets.chomp

    new_domain = domain_or_public(new_tenant_name)
    puts 'Domain not found' unless new_domain
    next unless new_domain

    printf 'What is the user_id whose topics you want to move?(id or all) '
    user_input = STDIN.gets.chomp

    printf 'Do you want to include all content within the topic(s)?(yes/no) '
    content_input = STDIN.gets.chomp

    @topic_map = {}

    printf 'What is the Topic ID of the topic you want to move?(id or all) '
    topic_input = STDIN.gets.chomp

    if user_input == 'all'
      printf 'Cycling through users'

      if topic_input == 'all'
        Apartment::Tenant.switch old_domain do
          member_class = old_domain == 'public' ? 'User' : 'DomainMember'

          eval(member_class).find_each(batch_size: 250) do |user|
            process_content(user, old_domain, new_domain, content_input, topic_input)
          end
        end
      else
        users = relevant_users_for(old_domain, topic_input)

        users.each do |user|
          process_content(user, old_domain, new_domain, content_input, topic_input)
        end
      end
    else
      user = User.find_by(id: user_input.to_i)
      next unless user

      process_content(user, old_domain, new_domain, content_input, topic_input)
    end
  end

  def relevant_users_for(old_domain, topic_input)
    users = []

    Apartment::Tenant.switch old_domain do
      topic_ids = topic_input.split(',').map(&:strip).map(&:to_i)
      topics = Topic.select(:id, :user_id, :ancestry).where(id: topic_ids)
      descendants = topics.map { |topic| topic.descendants.select(:id, :user_id, :ancestry) }
      all_topics = (topics + descendants).flatten.uniq
      users = all_topics.map(&:user)
    end

    users.uniq
  end

  def domain_or_public(tenant_name)
    return 'public' if tenant_name == 'public'

    domain = Domain.find_by(tenant_name: tenant_name)
    domain.tenant_name if domain.present?
  end

  def reassign_content_to(new_owner, content)
    new_id = new_owner.id

    puts 'Reassigning Content'
    content.each do |item|
      item.update_attribute(:user_id, new_id)
      printf '.'
    end
    puts 'Content Reassigned'
  end

  def process_content(user, old_domain, new_domain, content_input, topic_input)
    puts "Starting Topic Migration For User: #{user.name}"

    if topic_input == 'all'
      move_all_to_domain(user, old_domain, new_domain)
    else
      topic_ids = topic_input.split(',').map(&:strip).map(&:to_i)

      Apartment::Tenant.switch old_domain do
        topics = user.topics.where(id: topic_ids)
        puts 'Topic not found' if topics.blank?
        return if topics.blank?

        topics.each do |topic|
          move_to_domain(topic, old_domain, new_domain)
        end

        puts 'Topic Moved.'
      end
    end

    move_all_tips(user, @topic_map, old_domain, new_domain) if content_input == 'yes'
  end

  def move_all_to_domain(user, old_domain, new_domain)
    topics = []

    Apartment::Tenant.switch old_domain do
      topics = user.topics.without_root
    end

    topics.each do |topic|
      move_to_domain(topic, old_domain, new_domain)
    end

    puts "#{topics.size} Topics Moved To Domain: #{new_domain}"
  end

  def move_to_domain(old_topic, old_domain, new_domain, parent_id = nil)
    # TODO: create tips
    # TODO: tips follow new topic
    new_topic = old_topic.dup.attributes.merge({'ancestry' => nil, 'old_subtopic_id' => nil})

    newly_created_topic = nil
    Apartment::Tenant.switch new_domain do
      newly_created_topic = Topic.create(new_topic.merge(parent_id: parent_id))
      print '.'
    end

    @topic_map[old_topic.id] = newly_created_topic.id

    return unless old_topic.children?

    old_topic.children.each do |child|
      move_to_domain(child, old_domain, new_domain, newly_created_topic.id)
    end
  end # Move to domain

  def move_all_tips(user, topic_map, old_domain, new_domain)
    Apartment::Tenant.switch old_domain do
      print 'Starting Tip Migration'

      follows = Follow.includes(:follower).where(
        followable_type: 'Topic',
        followable_id: topic_map.keys,
        follower_type: 'Tip'
      )

      tips = follows.map(&:follower)

      tips = tips.uniq.compact #.select{ |tip| tip[:user_id] == user.id }
      puts "Tip Count: #{tips.count}"
      tips.each_with_index do |tip, index|
        print " tip #{index}:"
        tip_follows = follows.select{ |f| f[:follower_id] == tip.id }
        tip_following_topic_ids = tip_follows.map{ |cf| topic_map[cf.followable_id] }

        move_tip_to_domain(tip, tip_following_topic_ids, old_domain, new_domain)
      end
    end

    puts ' End Tip Migration'
  end

  def move_tip_to_domain(old_tip, following_topic_ids, old_domain, new_domain)
    new_tip = old_tip.dup

    attachment_map = []
    old_tip.attachments.each do |attachment|
      attachment_map << {
        attachment: attachment.dup,
        old_attachment_file_url: attachment.type == 'Link' ? '' : attachment.file_url
      }
    end

    Apartment::Tenant.switch new_domain do
      print ' t:'

      newly_created_tip = Tip.create(new_tip.attributes)

      # migrate_follows(newly_created_tip, following_topic_ids)
      # migrate_attachments(newly_created_tip, attachment_map)
      # migrate_comments(newly_created_tip, comment_list)
      # migrate_likes(newly_created_tip, likes_list)

      following_topic_ids.each do |follow_id|
        newly_created_tip.follow(Topic.find(follow_id)) rescue next
        print 'f'
      end

      attachment_map.each do |attachment_data|
        new_attachment = attachment_data[:attachment]

        next if new_attachment.blank?

        new_attachment.attachable_id = newly_created_tip.id
        # BUG: This should work, but we're getting Forbidden errors
        unless new_attachment.type == 'Link'
          new_attachment.remote_file_url = attachment_data[:old_attachment_file_url]
        end

        new_attachment.save

        print 'a'
      end
    end

    s3 = S3CopyObject.new(old_domain, new_domain)
    s3.copy_images(old_tip.id)
    s3.copy_documents(old_tip.id)
  end # move tip to domain
end
